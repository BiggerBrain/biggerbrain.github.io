<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>揭秘Kora:Kafka的云原生事件流处理平台</title>
    <link href="/2024/03/08/%E6%8F%AD%E7%A7%98Kora:Kafka%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%A4%84%E7%90%86%E5%B9%B3%E5%8F%B0/"/>
    <url>/2024/03/08/%E6%8F%AD%E7%A7%98Kora:Kafka%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%A4%84%E7%90%86%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>​VLDB，即（<strong>International Conference on Very Large Data Bases，大规模数据库国际会议，简称VLDB</strong>），是世界顶级的数据库学术会议之一。每年的VLDB都会聚集全球顶尖的数据库技术专家和创新者，分享他们的研究成果和实践经验。在今年的VLDB2023大会上，工业界的最佳论文《Kora: A Cloud-Native Event Streaming Platform For Kafka》荣获殊荣，其详述了Confluent公司基于Kafka设计的云原生事件流平台Kora的实现原理。作为一名专注于Kafka云原生内核技术和生态技术的开发者，一直关注着Kafka和Confluent等行业领先公司的动态。此奖项的颁发，再次证明Kafka在事件流处理领域的价值和竞争力。尽管科技日新月异，新技术层出不穷，然而Kafka和Confluent这样的经典技术还依然保持着竞争力和应用价值，实在令人欣慰。</p><p>​在讲Kora之前，让我们来了解一下Kora及Kafka和Confluent的发展历史。</p><p>​Kafka作为主要的事件队列和中间件，对许多互联网开发者来说并不陌生。然而，Kafka并非简单的消息队列，而是分布式事件流处理领域的佼佼者。它与传统消息中间件不同，一直聚焦在大数据、实时处理以及数据流领域。由于Kafka的出色表现，技术生态上逐渐诞生了Kafka core（事件流队列&#x2F;消息队列），Kafka Stream（事件流流式处理和分析），Kafka Connect（数据生态连接，连接上下游数据系统）等丰富的技术产品。</p><p>​互联网的飞速发展使得数据规模呈指数级增长，数据的重要性日益显著。无论是数据报表还是数据分析，亦或是机器学习和人工智能，都需要快速、准确的数据处理。这为流数据处理领域提供了巨大的市场和技术机遇。因此，Kafka的创始团队成立了以Kafka为核心的商业化技术公司——Confluent，并成功上市。截至撰写本文2024年3月，Confluent的市值高达104亿美元，这无疑是基础架构领域非ToC领域的成功案例。</p><p>​随着云计算的发展和普及，<strong>【云原生】</strong>概念的深入人心，从严格定义上，Kafka 最初是在非云原生世界中构建的，这使得它无法以经济有效且高效弹性的方式直接在当今云上的基础设施中使用，因此遭遇了诸多其他基于云原生设计的消息产品的技术挑战。</p><p>​针对Kafka的云原生化，在国内，各大云厂商诸如阿里云，腾讯云，字节等也在跟进推出自己的云原生化的事件流解决方案，其核心竞争力始终围绕<strong>【弹性】</strong>、<strong>【性能】</strong>和<strong>【成本】</strong>建设，有Alikafka，Ckafka，BMQ等产品；在创业领域，也诞生了一系列创业公司，如基于pulsar作为技术底座的<strong>StreamNative</strong>，其核心特征是计算与存储分离架构，带来的收益是【弹性】能力的极大提升；如100%兼容Kafka协议的<strong>AutoMQ</strong>，其核心竞争力目前也是存算分离架构提供极致的降本和极高的弹性。</p><p>​Confluent作为Kafka创始人孵化的创业团队，这个领域耕耘了十多年，对开源Kafka这些问题和痛点有意而为之，其本质原因是基于Kafka的云原生化存在十分重要的商业价值，既要在开源上处于领先地位，又需要在某些重要特性和功能上在商业化和开源上做出差异化，吸引客户付费使用，因此，在一些关键的特性上，开源是落后于商业化的。Kora的设计实现则首次披露了Confluent如何基于Kafka设计云原生事件流平台，可以打个比方，Kora，其对标的是国内各大云厂商诸如阿里云的Alikafka，腾讯云的Ckafka，华为云的Kafka等诸多大厂的云平台的设计实现。</p><p>​在云原生下，大规模运行 Kafka 面临着非常多的技术挑战，很欣慰能看到Kora的设计实现，笔者结合多年云计算流处理消息相关开发实践经验，发现其很多设计与国内各大云厂商不谋而合，但也有一些独到的实践值得借鉴和学习，笔者将在本文重点研究 Kora 提供的核心设计以及它使用哪些技术来构建大规模的云原生解决方案。</p><blockquote><p>论文：<a href="https://www.vldb.org/pvldb/vol16/p3822-povzner.pdf">https://www.vldb.org/pvldb/vol16/p3822-povzner.pdf</a></p></blockquote><h2 id="1-事件流"><a href="#1-事件流" class="headerlink" title="1 事件流"></a>1 事件流</h2><p>​在介绍Kora之前，先介绍<strong>事件流</strong>。事件流解决的是事件从生产到消费如何实时处理的问题，事件如流水一样持续不断的产生，相应的系统需要具备实时的处理能力。图1显示Kafka事件流系统的模型视图。Kafka在中间，生产者将数据写入日志的末尾，而消费者可以从任意偏移量中读取数据。事件由生产者写入Kafka之后，消费者可以通过Kafka的消费订阅，高扇出地即时地读取数据，可以这么理解，Kafka是大数据里面的<strong>高速公路</strong>。目前，Confluent收购了Flink初创团队创建的Immerok，数据的流式计算，流式存储和处理，流式传输正变得越来越紧密。</p><p><img src="/../images/image-20240311110641020.png"></p><center><p>事件流模型</p></center><h2 id="2-顶层设计"><a href="#2-顶层设计" class="headerlink" title="2 顶层设计"></a>2 顶层设计</h2><p>​Kora是云原生的事件流平台，云原生的Kora具备何种特性呢？Kora给出的答案是：除了开源Kafka具备的基本的高可用性，持久性和可扩展性外，还提供<strong>【弹性】</strong>、<strong>【成本效率】</strong>、<strong>【性能】</strong>、<strong>【多租户】</strong>和<strong>【跨云同步】</strong>等差异化能力。因此，Kora的设计存在两个层面的设计，一方面是有别开源Kafka的架构设计，另一方面是云原生方案的设计。</p><blockquote><ol><li>在Kafka的架构设计上，采用存算分离架构设计，元数据层面基于Raft协议实现分布式环境下的自我管理。这两个设计有效促进了Kafka的【弹性】、【性能】和【成本效率】的提升。</li><li>在云原生设计上，提供了最核心对资源的抽象设计-Confluent Kafka Units（简称CKU），CKU是【弹性】、【成本效率】、【性能】、【多租户】和【跨云同步】等核心云原生能力的基石。CKU解决的是在跨云和跨云下不同的硬件中提供一致的性能体验。Confluent Cloud与国内云厂商不同的点之一是横跨三种云(AWS、GCP、Azure)和73个地区的数万个集群，如何远离底层硬件，在追求最佳性价比的过程中试验更新的硬件类型和配置，提供一致的性能和体验是非常具有挑战的。虽然更新、更快的硬件在不断满足客户日益增长的性能需求，但现实是，如果要评估新硬件适配多样化的工作负载需求，想获得最佳性价比，需要大量的测试和投入。</li></ol></blockquote><h2 id="3-架构设计"><a href="#3-架构设计" class="headerlink" title="3 架构设计"></a>3 架构设计</h2><p>​本节介绍Kora的设计目标和架构设计。</p><h3 id="3-1-设计目标"><a href="#3-1-设计目标" class="headerlink" title="3.1 设计目标"></a>3.1 设计目标</h3><ul><li><p>可用性：单AZ提供99.95%的可用性，多AZ提供99.99%的可用性。</p></li><li><p>弹性：支持用户对集群规模的扩容和缩容，此外，Kora还提供自适应工作负载模式的变化，给集群大小提供最佳性能。</p></li><li><p>性能：高吞吐，低延迟，除了软件层面的优化，针对硬件资源，随着硬件资源的推陈出新，Kora会有意识地更新硬件资源，因此，随着时间的推移，用户可能会看到他们的应用程序的性能提升。</p></li><li><p>多租户：支持多租，尽可能降低客户成本。</p></li><li><p>多云支持：Kora运行在AWS、GCP和Azure上，最小化屏蔽云之间的资源差异，在服务交付上给用户提供统一的体验。</p></li></ul><h3 id="3-2-架构设计"><a href="#3-2-架构设计" class="headerlink" title="3.2 架构设计"></a>3.2 架构设计</h3><p><img src="/../images/image-20240311130734612.png"></p><center><p>Confluent Cloud中的控制面和数据面</p></center><p>​<strong>控制面和数据面解耦设计</strong>：如图2所示，分为集中式的控制面和分布式的数据平面。</p><p>​<strong>控制面承担资源管理的角色</strong>：控制面使用Kubernetes分配物理资源(包括计算、存储、网络等)以及初始化集群，在跨可用区场景中，集群会均匀分布在不同的可用区。</p><p>​<strong>数据面承担数据处理的角色</strong>：数据面由独立的物理Kafka集群( <strong>physical Kafka clusters，物理Kafka集群，简称PKC</strong>)组成和管控相关的微服务所构成。一个PKC托管一个或多个LKC（<strong>logical Kafka cluster，逻辑Kafka集群，简称LKC</strong>）。事件的生产和消费通过网络层流入和流出数据面。</p><blockquote><p>这里值得借鉴的是：数据面的网络层使用<strong>Proxy</strong>，通过SNI(服务器名称标识)路由到各个Broker。Proxy是无状态的，独立扩展，因此，可以支持大型集群且不会遇到端口耗尽等瓶颈。<strong>在多租场景，笔者就遇到过端口不足的问题</strong>。</p></blockquote><p>​控制面和数据面解耦在云计算或者基础架构领域可以说是比较常见的设计，Kora在生产环境上使用了两个比较重要的Kafka特性：第一，元数据自管理；第二，分层存储。</p><h3 id="3-3-元数据管理"><a href="#3-3-元数据管理" class="headerlink" title="3.3 元数据管理"></a>3.3 元数据管理</h3><p>​在分布式系统中，如何协调分布在不同机器的服务，实现一致性的数据管理在分布式领域一直都是核心问题。一般在分布式系统设计中，都会避免自己设计一致性协议，而采用传统的ZooKeeper进行分布式协调和管理元数据。Kafka在2.8之前就一直依赖ZooKeeper进行集中式地管理元数据，在2.8开始推出基于Raft协议的元数据自我管理，简称Kraft，在Kafka 3.6版本则标志生产可用，截止当下，Kafka最新版本是3.7，在未来的4.0会彻底去除ZooKeeper的依赖。</p><blockquote><p>为什么Kora要自己做元数据管理？</p><p>这是Kafka在技术演进上重要的一次升级。ZooKeeper是强一致性系统，因此性能不高，在百万分区下，会涉及大量的元数据同步和管理，基于ZooKeeper的元数据管理非常容易遇到性能问题，同时去ZK，会减少一个额外组件的运维，有利于系统的自我管理能力的进一步提升，因为Kafka比ZooKeeper更懂Kafka。这里额外对比一下Pulsar，Pulsar一直在挑战Kafka的地位，但是Pulsar存在一个问题，那就是部署和运维的组件较多，较复杂。好的技术产品，是需要将复杂问题闭环，对外部呈现最简单，最符合直觉的服务。</p></blockquote><p>​在元数自我管理方面，Kora有一个实践值得借鉴：那就是，元数据管理的节点独立部署，<strong>只承担元数据管理的角色</strong>，独立部署在<strong>滚动升级场景</strong>，会减少选举带来的不稳定性，在大规模部署Kafka场景下，这不失为是一种好的实践。</p><h3 id="3-4-分层存储"><a href="#3-4-分层存储" class="headerlink" title="3.4 分层存储"></a>3.4 分层存储</h3><p>​在2018时候，分层存储设计在Kafka开源领域的设计就提出来了，即<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-405%3A+Kafka+Tiered+Storage">KIP-405</a>，Kafka目前的存储和计算是在同一台机器上的，随着数据大小的增加，这种架构最终会成为瓶颈。目前3.6版本Kafka推出了分层存储，但是不建议生产可用，3.6的分层更接近是定义了使用的标准和协议，也就是一个框架，底层如何存储和处理数据还是需要开发者自己实现。</p><blockquote><p>为什么时间这么久，<strong>完整的分层存储</strong>没有开源？</p><ol><li>因为分层存储存在极大的商业价值，并非技术不可行，这是商业化和开源的区别，Kora在云上大规模使用了分层存储技术，该技术能提供无限存储，在大量数据，长时间的数据存储场景中，能极大降低客户成本。</li><li>在冷热数据中，冷数据的存储对接的可能是不同的系统，如亚马逊的S3，如HDFS，不同存储系统的存储的读写API都不一样，因此定义标准和协议更为现实。</li></ol></blockquote><p>​分层存储同时带来了一个非常好的优势，那就是<strong>【弹性】</strong>的极大提升。传统Kafka很难称为云原生，传统Kafka在扩缩容方面，涉及大量的数据迁移，因此Kafka的弹性效率不高。分层存储之后，只有少量热数据保留本地，因此在弹缩方面设计的数据迁移就很少，因此Kora在弹缩能力上比传统Kafka高很多，这个技术也是构建Kora云原生的核心基石。</p><h2 id="4-云原生的设计"><a href="#4-云原生的设计" class="headerlink" title="4 云原生的设计"></a>4 云原生的设计</h2><p>在本节中，我们将讨论如何设计Kora的云原生属性，本节中描述的构建模块也构成了我们多租户服务的基础。</p><blockquote><p>这节，我们能近距离明白具备什么特性才能成为云原生。Kora给出的答案是：资源模型与抽象、集群组织、弹性、可观测能力、自动迁移、数据容灾以及升级。</p></blockquote><h3 id="4-1-资源模型"><a href="#4-1-资源模型" class="headerlink" title="4.1 资源模型"></a>4.1 资源模型</h3><p>​<strong>资源模型</strong>：资源模型对提供真正的云原生体验非常重要，因为用户不必考虑云的底层细节，如CPU、内存、网络、IOPS&#x2F;吞吐量&#x2F;存储带宽等。Kora定义CKU（Confluent Kafka Units，Confluent的Kafka资源使用单位，简称CKU），CKU可以简单理解就是我们测距的米，测重的千克，测面积的平米等单位，一个CKU代表了客户能使用多少带宽&#x2F;请求速率&#x2F;网络连接总数&#x2F;建连速度。</p><blockquote><p>在定义了CKU后，在云上Kora的服务的提供都以CKU作为单位，但是呢？CKU是一种理想的设定，需要标准的使用方式才能使用好CKU，尤其是在云上，笔者对此感触颇深，云上的客户在使用方式千奇百怪，技术能力可能也参差不齐，往往存在诸多不佳实践，很难达到CKU的使用上限。因此Kora定义了集群负载的概念，用以衡量集群的负载。</p></blockquote><p>​<strong>集群负载</strong>：集群负载存在最大的挑战是：直接使用CPU、IOPS&#x2F;磁盘吞吐量或网络带宽不足并不科学，也不准确，在CPU很高时候，可能客户的延时并不大，可能客户运行的服务非常稳定，因此Kora使用<em><strong>Kingman公式的排队论定律</strong></em>来研究延迟和服务器利用率之间的关系。</p><blockquote><p>Confluent 基于<em><strong>Kingman公式的排队论定律</strong></em>，参数采用时延，系数则是通过大量的测试得出，因为不同云之间的资源性能不一致，因此每种云的系统都不一样。集群负载实施会较为复杂，因为需要大量测试确定系数，Kora对三种云的不同资源硬件进行了大量实验，在CPU密集型场景中，证明Kingman的排队定律计算的负载参数非常有效，在低CPU的场景下，Kora则会使用带宽利用率提供集群负载指标</p></blockquote><h3 id="4-2-集群组织"><a href="#4-2-集群组织" class="headerlink" title="4.2 集群组织"></a>4.2 集群组织</h3><p>​集群组织方面，Kora的设计和国内的思路设计基本一致，Kafka集群需要的各种微服务来实现可观察性、审计、计费等功能，这些功能Kora没有为这些服务提供专用资源，而是将它们与Kafka代理捆绑在一起，同时保留大约80%的VM资源供Kafka代理使用。</p><h3 id="4-3-弹性"><a href="#4-3-弹性" class="headerlink" title="4.3 弹性"></a>4.3 弹性</h3><p>​弹性：前面Kora定义了CKU作为资源的单位，Kora的弹性，即能根据工作负载不断变化，以CKU作为粒度增加或者减少资源，弹性是云原生核心特征也是技术竞争力，其中Kora的弹性设计主要如下核心点：</p><pre><code class="hljs">1. **自适应的数据均衡**：Kora改造了Kafka的Controller组件，增加了收集集群中每个Kafka代理的指标，集中式地实时掌握集群负载情况，并通过基于简单的启发式重新分配副本，因此实现自我数据平衡的能力。1. 元数据管理是基于Kraft协议独立部署和运行的，因此弹缩期间的选举造成的稳定性影响减少。1. 数据采用分层存储，因此资源弹缩过程（增加节点或者减少节点）迁移数据的量很少，弹缩性能提升很大。</code></pre><h3 id="4-4-可观测性"><a href="#4-4-可观测性" class="headerlink" title="4.4 可观测性"></a>4.4 可观测性</h3><p>​可观测性对于运行一个大型分布式系统至关重要，开源kafka提供了丰富的可观测指标，商业化提供更多的观测指标不足为奇，其中笔者认为Kora较为突出的设计是：</p><p>​<strong>端到端延时的设计</strong>：在传统情况下，我们可以很精确的了解服务端Broker的各种延迟指标和物理资源使用情况，但是事件诞生到Broker，Broker到消费者，这两个观测指标是游离分布式系统之外的。如何探测端到端的延迟，是一个非常有意义的挑战。为了弥补这一差距，Kora在每个集群中包括一个健康检查代理，该代理位于内部网络之外，并通过产生和消费请求不断探测端到端的延迟，以检测可用性或性能方面是否有损失。</p><h3 id="4-5-自动迁移"><a href="#4-5-自动迁移" class="headerlink" title="4.5 自动迁移"></a>4.5 自动迁移</h3><p>​由Kora支持的Confluent Cloud为多区域集群提供99.99%的正常运行时间SLA。因为Kora是在多云下提供服务，当底层不同的云厂商不都提供相同的SLA保证时，维护4个9的可用性具有挑战性，事实上，Confluent的数据披露大部分可用性失效是由云基础设施故障引起的，Kora针对这块的设计是：</p><p>​<strong>健康巡检</strong>：每个代理运行一个健康巡检线程，认为代理不健康会自动迁移，在传统情况，自动迁移如果涉及大量数据回来<strong>迁移风暴</strong>，但是依然得益于分层存储的设计，Kora的自动迁移效率很高。</p><h3 id="4-6-数据容灾"><a href="#4-6-数据容灾" class="headerlink" title="4.6 数据容灾"></a>4.6 数据容灾</h3><p>​在数据容灾方面，Kora有一个优秀的设计实践：<strong>镜像复制</strong>，Kora提供CLuster Link能力，比开源的mirrormaker2更强，允许在两个独立的Kafka集群之间以无缝的方式复制所有数据和所有元数据（<strong>包括不需要映射的消费位点</strong>）状态，因此，在源集群故障时候，只需将客户端指向新的集群端点即可。</p><h3 id="4-7-升级"><a href="#4-7-升级" class="headerlink" title="4.7 升级"></a>4.7 升级</h3><p>​<strong>升级</strong>：升级对核心服务的持续改进和创新至关重要，但是在大规模事件流处理过程，如何安全地尽可能降低抖动地升级是一个非常大的挑战也是持续打磨的过程。目前Kora的升级思路如下</p><pre><code class="hljs">1. 滚动升级，小集群只滚动一个，大集群滚动会多个，滚动下一组的过程会根据一系列内部健康指标是否达标在进行下一轮滚动。1. 跨可用区实例确保所有副本不会在同一个可用区，减少滚动的影响。</code></pre><h2 id="5-多租户设计"><a href="#5-多租户设计" class="headerlink" title="5 多租户设计"></a>5 多租户设计</h2><p>​多租户能在大规模场景下，提供真正的云原生体验:更高层次的资源抽象、弹性和随用随付模型以及<strong>更低的成本</strong>，但是多租户的设计是非常具有挑战的，尤其是云上面对的客户来自各行各业，其中<strong>资源隔离</strong>是最核心的技术挑战，因为隔离如果没有做到位的话，很容易互相影响，造成故障。</p><h3 id="5-1-逻辑集群"><a href="#5-1-逻辑集群" class="headerlink" title="5.1 逻辑集群"></a>5.1 逻辑集群</h3><p>​<strong>命名空间隔离</strong>，设计了逻辑Kafka的概念，LKC的数据隔离是通过身份验证(通过API密钥)、授权和加密实现的。Kafka本身不支持命名空间隔离。Kora通过使用相应的逻辑集群ID(每个LKC的唯一标识符)标志每个集群资源(主题、消费者组、acl等)使用。</p><p><img src="/../images/image-20240311110318469.png"></p><p><img src="/../images/image-20240311110318469.png"></p><center><p>逻辑集群ID命名空间隔离</p></center><center><p></p></center><h3 id="5-2-性能隔离"><a href="#5-2-性能隔离" class="headerlink" title="5.2 性能隔离"></a>5.2 性能隔离</h3><p>​<strong>资源隔离设计</strong>：Kora实施租户级配额来实现性能隔离，隔离的资源分别如下:</p><blockquote><ol><li>入口和出口带宽：通过配额机制实现，当触发带宽额度后，会对客户连接进行静默处理。</li><li>CPU使用：对请求和请求处理时间进行限制，当请求处理时间大于限定值会静默处理。</li><li>网络连接数量：限定网络连接数量，超过一定的连接数会报错。</li><li>连接尝试率：限定网络重连的时间间隔，超过限度会报错。</li><li>内存：影响内存使用的工作负载行为配额。分区数创建&#x2F;删除配额：业务上限定分区数的总数。</li></ol></blockquote><p>​<strong>分布式配额设计</strong>：在随用随付模式下，由于大多数租户使用的带宽远远低于其逻辑集群的最大带宽容量，但是多租户下，不同租户的峰值时间不一，负载分布在不同的节点，不同时刻，不同节点的负载也不一样，如何有效利用集群资源提供更好的服务，Kora通过使用动态配额机制来解决这个问题。该机制根据租户的带宽消耗来调整带宽分配。这是通过使用共享配额服务来管理配额分配来实现的，这种设计如下：</p><blockquote><ol><li>定义节点的最大物理带宽额度</li><li>提供配<strong>额协调器</strong>用于分布式节点流量的收集和处理</li><li>节点定期向配额协调器上报每个租户和每个Broker的带宽使用数据和相关的限额信息</li><li><strong>配额协调器</strong>汇总这些数据，重新计算每个代理-租户对的还能使用多少额度，并以将可使用的额度分发给相关节点</li><li>为了适应大型多租户环境，部署了多个<strong>配额协调器</strong>，Broker通过哈希将每个配额实体映射到一个<strong>配额协调器</strong></li></ol></blockquote><p><img src="/../images/image-20240311130443738.png"></p><center><p>配额协调器设计</p></center><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>​当下，互联网技术在不断发展，回顾过去，短短几年，从移动化，大数据，云计算，区块链到现在的人工智能，世界的发展日新月异。而这些技术的背后也催生了大量的数据，数据的价值被证明意义非凡，和水、电、燃气一样无处不在，而实时数据的处理需求，让事件流系统也成为越来越重要的基础设施，Kafka目前是事件流的领导者，Confluent也在不断的往事件流的流处理和流计算发展，Kora在某种程度上也代表了这个技术的前沿，VLDB 2023这篇工业界的Best Paper披露了很多好的设计和实践，非常值得我们借鉴。技术在不断发展，新的前沿的知识需要终身我们不断持续学习，百尺竿头，更进一步。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好网导航</title>
    <link href="/2024/02/27/%E5%A5%BD%E7%BD%91%E5%AF%BC%E8%88%AA/"/>
    <url>/2024/02/27/%E5%A5%BD%E7%BD%91%E5%AF%BC%E8%88%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="ainavpro是什么"><a href="#ainavpro是什么" class="headerlink" title="ainavpro是什么"></a>ainavpro是什么</h1><p>ainavpro是一个专注于人工智能产品的导航站。在这里，您可以找到各种各样的AI工具、应用、技术，以及商业应用等等。我们对AI产品进行了分类，包括文本处理、图片处理、代码工具、音频处理、视频处理、3D建模、商业应用、以及其他等等，方便您快速找到所需的工具和资源。地址：<a href="https://www.ainavpro.com/">https://www.ainavpro.com/</a><br><img src="/../images/image-20230315142629749.png" alt="AI大全地址"></p><h1 id="Clibrary图书馆是什么"><a href="#Clibrary图书馆是什么" class="headerlink" title="Clibrary图书馆是什么"></a>Clibrary图书馆是什么</h1><p>Clibrary图书馆，一个免费电子书下载网站、电子书搜索引擎，Clibrary图书馆于2022年9月建立，旨在维护知识自由，网站电子书、图书来自Z-Library，免费电子书下载网站Clibrary图书馆于2023年初进行升级，效仿Anna’s<br>archive使用IPFS提供文件服务，目前提供免费无限制的下载电子书服务，直接搜索电子书名即可下载。地址：<a href="https://clibrary.cn/#/">https://clibrary.cn/#/</a></p><p><img src="/../images/image-20230315143055269.png" alt="image-20230315143055269"></p><h1 id="heapdump是什么"><a href="#heapdump是什么" class="headerlink" title="heapdump是什么"></a>heapdump是什么</h1><p>有性能问题，上HeapDump性能社区，地址：<a href="https://heapdump.cn/">https://heapdump.cn/</a></p>]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>好网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-寻找两个正序数组的中位数</title>
    <link href="/2023/03/21/%E7%AE%97%E6%B3%95-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2023/03/21/%E7%AE%97%E6%B3%95-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组nums1 和nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2<br>示例 2：</p><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>提示：</p><p>nums1.length &#x3D;&#x3D; m<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m &lt;&#x3D; 1000<br>0 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; m + n &lt;&#x3D; 2000<br>-106 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 106</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-接雨水</title>
    <link href="/2023/03/16/%E7%AE%97%E6%B3%95-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2023/03/16/%E7%AE%97%E6%B3%95-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="/../images/image-20230316170925769.png" alt="示意图"></p><p>示例 1：</p><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>示例 2：</p><p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p><p>提示：</p><p>n &#x3D;&#x3D; height.length<br>1 &lt;&#x3D; n &lt;&#x3D; 2 * 104<br>0 &lt;&#x3D; height[i] &lt;&#x3D; 105</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h3 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h3><p>对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] h)</span> &#123;<br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span> || h.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> h.length;<br>        <span class="hljs-type">int</span>[] lMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span>[] rMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        lMax[<span class="hljs-number">0</span>] = h[<span class="hljs-number">0</span>];<br>        rMax[len - <span class="hljs-number">1</span>] = h[len - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            lMax[i] = Math.max(lMax[i - <span class="hljs-number">1</span>], h[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            rMax[i] = Math.max(rMax[i + <span class="hljs-number">1</span>], h[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            total += (Math.min(lMax[i], rMax[i]) - h[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-括号系列</title>
    <link href="/2023/03/16/%E7%AE%97%E6%B3%95-%E6%8B%AC%E5%8F%B7%E7%B3%BB%E5%88%97/"/>
    <url>/2023/03/16/%E7%AE%97%E6%B3%95-%E6%8B%AC%E5%8F%B7%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h1><p>给你一个只包含 ‘(‘和 ‘)’的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例 1：</p><p>输入：s &#x3D; “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”<br>示例 2：</p><p>输入：s &#x3D; “)()())”<br>输出：4<br>解释：最长有效括号子串是 “()()”<br>示例 3：</p><p>输入：s &#x3D; “”<br>输出：0</p><p>提示：<br>0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 104<br>s[i] 为 ‘(‘ 或 ‘)’</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-无重复字符的最长子串</title>
    <link href="/2023/03/16/%E7%AE%97%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2023/03/16/%E7%AE%97%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:<br>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p><code>请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方法一：滑动窗口思路"><a href="#方法一：滑动窗口思路" class="headerlink" title="方法一：滑动窗口思路"></a>方法一：滑动窗口思路</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 滑动窗口思路</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        HashSet&lt;Character&gt; occ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = i; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; len &amp;&amp; !occ.contains(s.charAt(j))) &#123;<br>                occ.put(s.charAt(j));<br>                res = Math.max(res, j - i + <span class="hljs-number">1</span>);<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == len) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            occ.remove(s.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：队列法"><a href="#方法二：队列法" class="headerlink" title="方法二：队列法"></a>方法二：队列法</h2><p>滑动窗口本质上也是队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//队列保存不重复的子串</span><br>        Queue&lt;Character&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">//使用集合，保存已经添加的字符，用于判断重复，提高性能</span><br>        HashSet&lt;Character&gt; occ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (!occ.contains(c)) &#123;<br>                queue.add(c);<br>                occ.add(c);<br>                i++;<br>                res = Math.max(queue.size(), res);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Character</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> queue.poll();<br>                occ.remove(cc);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-拓扑排序与搜索系列</title>
    <link href="/2023/03/15/%E7%AE%97%E6%B3%95-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%B3%BB%E5%88%97/"/>
    <url>/2023/03/15/%E7%AE%97%E6%B3%95-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>你这个学期必须选修 numCourses 门课程，记为0到numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组prerequisites 给出，其中prerequisites[i] &#x3D; [ai, bi]<br>，表示如果要学习课程ai 则 必须 先学习课程 bi 。 例如，先修课程对[0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p>输入：<code>numCourses = 2, prerequisites = [[1,0]]</code><br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。<br>示例 2：</p><p>输入：<code>numCourses = 2, prerequisites = [[1,0],[0,1]]</code><br>输出：false<br>解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</p><p>提示：</p><p><code>1 &lt;= numCourses &lt;= 105</code><br><code>0 &lt;= prerequisites.length &lt;= 5000</code><br><code>prerequisites[i].length == 2</code><br><code>0 &lt;= ai, bi &lt; numCourses</code><br><code>prerequisites[i] 中的所有课程对 互不相同</code></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方法一：深度搜索"><a href="#方法一：深度搜索" class="headerlink" title="方法一：深度搜索"></a>方法一：深度搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] visited;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> canFinish;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(numCourses);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] pre : prerequisites) &#123;<br>            edges.get(pre[<span class="hljs-number">0</span>]).add(pre[<span class="hljs-number">1</span>]);<br>        &#125;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        canFinish = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.size() &amp;&amp; canFinish; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span>) &#123;<br>                dfs(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> canFinish;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!canFinish) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        visited[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (Integer next : edges.get(i)) &#123;<br>            <span class="hljs-keyword">if</span> (visited[next] == <span class="hljs-number">0</span>) &#123;<br>                dfs(next);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visited[next] == <span class="hljs-number">1</span>) &#123;<br>                canFinish = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        visited[i] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="方法二：广度搜索"><a href="#方法二：广度搜索" class="headerlink" title="方法二：广度搜索"></a>方法二：广度搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-type">int</span>[] indeg;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>        indeg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] info : prerequisites) &#123;<br>            edges.get(info[<span class="hljs-number">1</span>]).add(info[<span class="hljs-number">0</span>]);<br>            ++indeg[info[<span class="hljs-number">0</span>]];<br>        &#125;<br><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">visited</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            ++visited;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : edges.get(u)) &#123;<br>                --indeg[v];<br>                <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(v);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> visited == numCourses;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>拓扑排序</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出系列-零拷贝</title>
    <link href="/2023/03/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2023/03/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>零拷贝技术是一种优化数据传输的技术，可以避免在内存中进行多次数据复制，从而提高数据传输的效率和降低对CPU的负载。具体来说，零拷贝技术可以通过以下方式实现：</p><p>DMA传输：网卡通过DMA（Direct Memory Access）直接读取或写入内存中的数据，而不需要CPU的干预。这样可以避免CPU在数据传输过程中的处理和复制操作。</p><p>文件描述符传递：应用程序可以将文件描述符通过sendfile()系统调用传递给内核，由内核直接将文件数据写入网络套接字中，避免了在内存中进行多次数据复制。</p><p>内存映射文件传输：应用程序将文件映射到内存中，然后直接将内存中的数据写入网络套接字中。由于数据直接从文件映射区域传输，避免了在内存中进行数据复制的过程。</p><p>零拷贝技术可以显著提高数据传输的效率和性能，特别是在大文件传输和高并发传输场景下。</p><h1 id="零拷贝-网络数据"><a href="#零拷贝-网络数据" class="headerlink" title="零拷贝-网络数据"></a>零拷贝-网络数据</h1><p>网络数据从接收到写入的整个拷贝过程通常包括以下几个步骤：</p><ol><li>网卡接收数据：当数据包到达网卡时，网卡会将数据包存储在接收缓冲区中。</li><li>中断请求：网卡将中断请求发送给CPU，以通知系统有新数据到达。</li><li>系统调用：操作系统会调用相应的网络驱动程序来处理这个中断请求，并将数据从网卡接收缓冲区复制到内核缓冲区中。</li><li>内核缓冲区到用户缓冲区的拷贝：应用程序通过系统调用将数据从内核缓冲区拷贝到用户缓冲区中。</li><li>应用程序处理数据：应用程序可以对数据进行处理或者展示等操作。</li></ol><p>在传统的网络数据处理中，这个拷贝过程会涉及到多次数据复制的操作，增加了系统的开销和延迟。而网卡零拷贝技术可以避免在内存中进行多次数据复制，从而提高数据传输的效率和降低对CPU的负载。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出系列-Top命令</title>
    <link href="/2023/03/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-Top%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/03/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-Top%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Top命令"><a href="#Top命令" class="headerlink" title="Top命令"></a>Top命令</h1><p>top命令是一个类Unix系统上的应用程序，用于显示当前运行进程的相关信息，如进程的ID、CPU利用率、内存利用率等。它可以实时显示系统的运行情况，可以帮助用户监视系统资源的使用情况，以及识别和优化系统性能的瓶颈。top命令可以通过命令行或终端窗口来使用，通常被系统管理员、运维人员和开发人员用来进行系统监视和分析。</p><h1 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h1><p>top命令常用的参数：</p><ol><li>-d delay：指定top命令刷新的时间间隔，默认是3秒。</li><li>-n iterations：指定top命令执行的次数。</li><li>-p pid：显示指定进程ID的进程信息。</li><li>-U username：显示指定用户名的进程信息。</li><li>-u username：仅显示指定用户名的进程信息。</li><li>-i：不显示闲置的进程。</li><li>-H：显示进程的层次结构。</li><li>-c：显示命令的完整路径。</li><li>-M：以MB为单位显示内存占用量。</li><li>-T：显示进程的线程数。</li><li>-b：以批处理模式运行top命令，将输出写入指定文件。</li><li>-o field：按指定字段排序，如-CPU、-MEM等。</li><li>-S：按照CPU利用率进行排序。</li><li>-s delay：指定在批处理模式下每次刷新的时间间隔。</li><li>-h：显示帮助信息。</li></ol><p>注意：参数可以组合使用，如top -d5 -p1234 显示进程ID为1234的进程信息，并每5秒刷新一次。</p><h1 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h1><p>以下是top命令常用的方式：</p><ol><li>查看全局系统信息：直接在终端输入top命令即可查看当前系统的进程信息、CPU、内存等状态信息。</li><li>查看指定进程信息：使用top命令的-p参数可以查看指定进程的相关信息，如top -p1234，即可查看进程ID为1234的进程信息。</li><li>排序查看进程信息：使用top命令的-o参数可以按照指定的字段进行进程信息排序查看，如top -o %CPU，即可按照CPU占用率进行排序。</li><li>批处理模式：使用top命令的-b参数可以开启批处理模式，在后台运行top命令并将输出写入指定文件中，如top -b -n5 &gt; output.txt，即可在5次执行后将结果保存至output.txt文件中。</li><li>实时监控选项：使用top命令的-d参数可以改变top命令的刷新间隔，实现实时监控进程状态，如top -d1，即每秒刷新一次进程信息。</li></ol><p>6.交互式操作：在top命令界面中，可以使用不同的快捷键进行交互式操作，如h键查看帮助信息、k键终止指定进程、q键退出top命令等。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出系列-TCP</title>
    <link href="/2023/03/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-TCP/"/>
    <url>/2023/03/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p>TCP（Transmission Control<br>Protocol）协议是一种面向连接的、可靠的、基于字节流的传输控制协议。它是Internet协议族中最重要的协议之一，用于保证网络传输的可靠性和正确性。TCP协议通过三次握手建立连接、流量控制、拥塞控制、数据传输、序列号管理等机制，为应用层提供了一种可靠的传输服务。TCP协议是一个复杂的协议，但由于其可靠性和广泛的应用场景，成为了互联网传输中不可或缺的一部分。</p><h1 id="TCP的关键机制"><a href="#TCP的关键机制" class="headerlink" title="TCP的关键机制"></a>TCP的关键机制</h1><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>TCP连接是一种基于TCP协议的网络连接，用于在互联网上进行数据传输。TCP连接是一种面向连接的连接，它提供了可靠的、有序的、全双工的数据传输服务。</p><p>TCP连接的建立需要三次握手过程。客户端首先向服务器发送一个SYN包，表示请求建立连接。服务器收到SYN包后，回复一个SYN&#x2F;ACK包，表示已收到请求，并准备好建立连接。客户端再回复一个ACK包，表示确认建立连接。三次握手完成后，TCP连接成功建立。</p><p>TCP连接的维持需要保持心跳包和窗口控制等机制，以避免TCP连接的超时和丢失。TCP连接的关闭需要四次挥手过程。客户端首先发送一个FIN包，表示要关闭连接，服务器收到后回复一个ACK包，表示已收到请求。服务器在关闭之前也需要发送一个FIN包，表示已准备好关闭连接，客户端收到后回复一个ACK包，表示确认关闭连接。四次挥手完成后，TCP连接成功关闭。</p><p>TCP连接提供了可靠的数据传输，但是也存在一些缺点，例如连接建立时间长、连接维护的开销较高等。因此，在某些场景下，如实时音视频传输等，可能会使用UDP协议进行数据传输，以避免TCP连接的缺点。</p><h2 id="TCP四元组"><a href="#TCP四元组" class="headerlink" title="TCP四元组"></a>TCP四元组</h2><p>TCP四元组是指TCP协议在通信过程中所使用的四个重要参数，它们分别是：</p><ol><li>源IP地址：指发送数据包的主机IP地址。</li><li>源端口号：指发送数据包的应用程序使用的端口号。</li><li>目的IP地址：指接收数据包的主机IP地址。</li><li>目的端口号：指接收数据包的应用程序使用的端口号。</li></ol><p>四个参数共同组成了TCP连接的唯一标识，也是TCP协议进行数据传输所必需的重要参数。在TCP连接建立时，这四个参数被称为“三次握手参数”，在TCP连接中，这四个参数也被称为“TCP连接标识符”。</p><p>在TCP连接中，每个数据包都会包含这四个参数，并且在收到数据包时，TCP协议会根据这四个参数来确定数据包所要发往的应用程序。这四个参数的唯一性保证了TCP连接的正确性和可靠性，同时也为网络管理和安全监控提供了基础。</p><h2 id="序列号管理"><a href="#序列号管理" class="headerlink" title="序列号管理"></a>序列号管理</h2><p>TCP协议的序列号管理主要用于处理数据的可靠传输。在TCP连接建立成功后，每个TCP报文段都会被分配一个序列号。发送方在发送数据时，会将数据分割成若干个数据块，并为每个数据块分配一个序列号。接收方在接收数据时，会根据序列号将数据块按序接收，并通过确认序列号告知发送方已经接收了哪些数据。</p><p>序列号的作用是用于区分不同报文段的数据块，以保证数据的正确性和可靠性。序列号的初始值是随机选择的，可以防止重复数据包的出现。TCP协议还提供了窗口控制机制，用于限制发送方不要一次性发送过多的数据，防止网络拥塞。接收方会向发送方发送一个窗口大小的值，表示可以接收的数据量，如果发送方发送的数据大小超出窗口大小，接收方会拒绝接收，直到窗口大小再次增大。</p><p>通过序列号管理机制，TCP协议可以保证数据的可靠传输，对于丢失、重传等问题都有相应的处理方法，保证了网络传输的正确性和可靠性。</p><h2 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h2><p>TCP的滑动窗口是一种流量控制机制，用于限制发送方发送数据的速率，以防止网络拥塞和数据丢失。滑动窗口的大小表示接收端可以接收的数据量大小，发送端需要根据接收端的窗口大小来决定发送的数据量。</p><p>滑动窗口的原理是，接收端会向发送端发送一个窗口大小的值（例如，32KB），表示可以接收的数据大小。发送端会根据窗口大小来发送数据，当发送的数据被接收端确认接收后，窗口会向前滑动，表示接收端又可以接收新的数据。如果窗口大小为0，表示接收端暂时无法接收数据。</p><p>在TCP连接建立时，发送端和接收端会协商窗口大小的初始值，并在传输数据过程中动态调整窗口大小，以适应网络拥塞情况和接收端的接收能力。当网络拥塞时，接收端可以通过减小窗口大小来限制发送端的发送速率，以避免网络拥塞。当网络畅通时，接收端可以通过增大窗口大小来提高传输效率。</p><p>滑动窗口机制可以保证TCP传输的可靠性和流量控制，同时还能够提高传输效率，是TCP协议中的重要机制之一。</p><h2 id="TCP的拥塞窗口"><a href="#TCP的拥塞窗口" class="headerlink" title="TCP的拥塞窗口"></a>TCP的拥塞窗口</h2><p>TCP的拥塞窗口是一种拥塞控制机制，用于避免网络拥塞和网络阻塞问题。拥塞窗口的大小表示发送方可以发送数据的最大量。当网络出现拥塞或拥塞风险时，发送方需要适当减小拥塞窗口的大小，以避免过多的数据流入网络，导致网络拥塞或阻塞。</p><p>TCP的拥塞窗口是通过拥塞控制算法来实现的。TCP的拥塞控制算法主要有四种，包括慢启动、拥塞避免、快速重传和快速恢复。其中，慢启动算法是TCP拥塞控制算法的核心。它会在TCP连接建立时，以指数级别的方式逐渐增加拥塞窗口的大小，直到出现拥塞或达到最大窗口值，然后根据拥塞情况适当调整拥塞窗口的大小。</p><p>拥塞避免算法则是在拥塞窗口达到一定阈值后，将拥塞窗口的增长率降低，以避免过多数据流入网络，导致网络拥塞。快速重传和快速恢复算法是用于应对数据包丢失和数据包超时的情况，可以快速恢复数据传输并避免网络拥塞。</p><p>总的来说，TCP的拥塞窗口是TCP协议中的一个重要机制，用于控制数据的传输速率和避免网络拥塞，是TCP协议保证传输的可靠性和网络性能的重要机制之一。</p><h2 id="TCP的拥塞窗口和滑动窗口的区别"><a href="#TCP的拥塞窗口和滑动窗口的区别" class="headerlink" title="TCP的拥塞窗口和滑动窗口的区别"></a>TCP的拥塞窗口和滑动窗口的区别</h2><p>TCP流量控制和拥塞控制是TCP协议中的两个重要机制，它们的作用不同，具体区别如下：</p><ol><li>流量控制</li></ol><p>TCP流量控制主要是为了防止接收方的缓存溢出，即当数据发送过快，接收方不能及时处理时，TCP会通过发送方的窗口大小进行调整，控制发送方的发送速率。</p><ol><li>拥塞控制</li></ol><p>TCP拥塞控制主要是为了防止网络拥塞，当网络负载过重时，TCP会通过拥塞窗口大小的调整来控制发送方的发送速率，避免因网络拥塞而导致的数据丢失或延迟。</p><p>因此，TCP流量控制主要是为了防止接收方缓存溢出，而TCP拥塞控制主要是为了避免网络拥塞，两者的目的不同，但都是为了保证TCP数据的可靠传输。</p><h2 id="TCP挥手为什么四次而不是三次"><a href="#TCP挥手为什么四次而不是三次" class="headerlink" title="TCP挥手为什么四次而不是三次"></a>TCP挥手为什么四次而不是三次</h2><p>TCP挥手需要四次握手，原因如下：</p><ol><li>第一次挥手：客户端发送FIN包，告诉服务器端它将不会再发送数据。</li><li>第二次挥手：服务器端收到FIN包后，确认收到了客户端的请求，但它仍然可以向客户端发送数据，并且在发送完毕后关闭连接，因此需要先发送ACK包表示已经收到了客户端的请求。</li><li>第三次挥手：当服务器端发送完最后一条数据后，它需要发出FIN包，告诉客户端它将关闭连接。</li><li>第四次挥手：客户端收到FIN包后，发送ACK包确认收到，并告诉服务器端它也将关闭连接。</li></ol><p>因此，第四次挥手是必要的，用于客户端确认已收到服务器端的关闭请求后，也关闭连接，否则可能会导致服务器端一直处于半关闭状态，浪费资源。</p><h2 id="TCP握手为什么是三次而不是两次"><a href="#TCP握手为什么是三次而不是两次" class="headerlink" title="TCP握手为什么是三次而不是两次"></a>TCP握手为什么是三次而不是两次</h2><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列。序列号能够保证数据包不重复、不丢弃和按序传输。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出系列-如何设计高并发架构</title>
    <link href="/2023/03/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/03/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="高并发概述"><a href="#高并发概述" class="headerlink" title="高并发概述"></a>高并发概述</h1><p>高并发系统是指能够同时处理大量请求的计算机系统。例如，电子商务网站在促销活动期间可能会面临大量用户同时登录、浏览和购买商品的情况。这就需要系统在短时间内处理大量的请求，保证网站的稳定性和用户体验。高并发系统需要具备高性能、高可用性、可扩展性、可靠性等特点。</p><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>要设计高并发系统，需要做以下几件事：</p><ol><li><p>分析需求：明确系统的业务流程、访问量、响应时间和用户活跃度等关键参数。</p></li><li><p>预估负载：对系统的最大访问量、并发量、并发连接数和数据处理量进行预估和测试。</p></li><li><p>选择合适的技术栈：根据预估的负载，选择合适的技术栈，包括操作系统、编程语言、数据库、缓存等。</p></li><li><p>分层设计：将整个系统分层，分为应用层、服务层、数据层、缓存层等，对每一层进行优化和负载均衡。</p></li><li><p>选取合适的架构模式：选择合适的架构模式，如微服务架构、分布式计算架构等，以保证系统的可扩展性和容错性。</p></li><li><p>使用缓存和CDN：利用缓存和CDN技术，缓存热门数据和静态资源，减轻数据库和网络的负担。</p></li><li><p>异步处理：采用异步处理和消息队列技术，解决高并发带来的瓶颈问题。</p></li><li><p>负载均衡：使用负载均衡技术，将请求均衡分布到不同的服务器上，避免单一服务器的负载压力过大。</p></li><li><p>故障转移和容错：通过采用多节点、备份、自动切换等措施，保证系统即使发生故障，也能自动恢复并保持高可用性。</p></li><li><p>监控和优化：对系统进行监控和优化，保持高性能和可靠性。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-二维数组查找系列</title>
    <link href="/2023/03/07/%E7%AE%97%E6%B3%95-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E7%B3%BB%E5%88%97/"/>
    <url>/2023/03/07/%E7%AE%97%E6%B3%95-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例，现有矩阵 matrix 如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">        <span class="hljs-comment">[1,4,7,11,15]</span>,</span><br><span class="hljs-comment">        <span class="hljs-comment">[2,5,8,12,19]</span>,</span><br><span class="hljs-comment">        <span class="hljs-comment">[3,6,9,16,22]</span>,</span><br><span class="hljs-comment">        <span class="hljs-comment">[10,13,14,17,24]</span>,</span><br><span class="hljs-comment">        <span class="hljs-comment">[18,21,23,26,30]</span></span><br><span class="hljs-comment">        ]</span><br></code></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><p>限制：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">0</span>&lt;<span class="hljs-operator">=</span>n&lt;<span class="hljs-operator">=</span><span class="hljs-number">1000</span><br><span class="hljs-number">0</span>&lt;<span class="hljs-operator">=</span>m&lt;<span class="hljs-operator">=</span><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><img src="/../images/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="二叉搜索"></p><h3 id="1-二叉搜索"><a href="#1-二叉搜索" class="headerlink" title="1. 二叉搜索"></a>1. 二叉搜索</h3><p>我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值<br>target 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = c - <span class="hljs-number">1</span>; i &lt; r &amp;&amp; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; c; ) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h1><p>编写一个高效的算法来判断m x n矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p><p><img src="/../images/image-20230315115307073.png" alt="示例图"></p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><h3 id="1-二分搜索"><a href="#1-二分搜索" class="headerlink" title="1. 二分搜索"></a>1. 二分搜索</h3><p>映射到数据，进行二分查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, h = r * c - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (h - l) / <span class="hljs-number">2</span> + l;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">midValue</span> <span class="hljs-operator">=</span> matrix[mid / c][mid % c];<br>            <span class="hljs-keyword">if</span> (midValue == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &lt; target) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-用两个栈实现队列</title>
    <link href="/2023/02/28/%E7%AE%97%E6%B3%95-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead操作返回 -1 )</p><p>示例 1：</p><p>输入：<br><code>[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</code><br><code>[[],[3],[],[],[]]</code><br>输出：</p><p><code>[null,null,3,-1,-1]</code><br>示例 2：</p><p>输入：<br><code>[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</code><br><code>[[],[],[5],[2],[],[]]</code><br>输出：</p><p><code>[null,-1,null,null,5,2]</code><br>提示：</p><p><code>1 &lt;= values &lt;= 10000</code><br>最多会对appendTail、deleteHead 进行10000次调用</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方法一：双栈"><a href="#方法一：双栈" class="headerlink" title="方法一：双栈"></a>方法一：双栈</h2><p>思路：将一个栈当作输入栈，用于压入appendTail 传入的数据；另一个栈当作输出栈，用于deleteHead 操作。每次<br>deleteHead时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CQueue</span>()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        <span class="hljs-keyword">in</span>.push(<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">deleteHead</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">out</span>.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>.pop();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">in</span>.isEmpty()) &#123;<br>            <span class="hljs-keyword">out</span>.push(<span class="hljs-keyword">in</span>.pop());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">out</span>.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-数组中重复的数字数组中重复的数字</title>
    <link href="/2023/02/28/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3</p><p>限制：</p><p>2 &lt;&#x3D; n &lt;&#x3D; 100000</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p><p>![image-20230228172007718](&#x2F;Users&#x2F;lishixiong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230228172007718.png)</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>    public int findRepeatNumber(int<span class="hljs-comment">[]</span> nums) &#123;<br>        for(int i=0;i&lt;nums.length;)&#123;<br>            if(nums<span class="hljs-comment">[i]</span>==i)&#123;<br>                i++;<br>            &#125;else&#123;<br>                if(nums<span class="hljs-comment">[nums<span class="hljs-comment">[i]</span>]</span>==nums<span class="hljs-comment">[i]</span>)&#123;<br>                    return nums<span class="hljs-comment">[i]</span>;<br>                &#125;<br>                int tmp = nums<span class="hljs-comment">[nums<span class="hljs-comment">[i]</span>]</span>;<br>                nums<span class="hljs-comment">[nums<span class="hljs-comment">[i]</span>]</span> = nums<span class="hljs-comment">[i]</span>;<br>                nums<span class="hljs-comment">[i]</span>= tmp;<br>            &#125;<br>        &#125;<br>        return -1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-TopK问题</title>
    <link href="/2022/12/29/%E7%AE%97%E6%B3%95-TopK%E9%97%AE%E9%A2%98/"/>
    <url>/2022/12/29/%E7%AE%97%E6%B3%95-TopK%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr &#x3D; [3,2,1], k &#x3D; 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p><p>输入：arr &#x3D; [0,1,2,1], k &#x3D; 1<br>输出：[0]</p><p>限制：</p><p><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code><br><code>0 &lt;= arr[i] &lt;= 10000</code></p><h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>输入：<code>&#123;1,2,3&#125;</code></p><p>返回值：<code>&#123;3,2,1&#125;</code></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方案一：利用大根堆"><a href="#方案一：利用大根堆" class="headerlink" title="方案一：利用大根堆"></a>方案一：利用大根堆</h2><p>java默认的是小根堆，我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1<br>个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span> || k &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt;= arr.length) &#123;<br>            <span class="hljs-keyword">return</span> arr.clone();<br>        &#125;<br>        PriorityQueue&lt;Integer&gt; bigEndQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k, Comparator.reverseOrder());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            bigEndQueue.offer(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; bigEndQueue.peek()) &#123;<br>                bigEndQueue.poll();<br>                bigEndQueue.offer(arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res[i] = bigEndQueue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方案二：利用partition的思想"><a href="#方案二：利用partition的思想" class="headerlink" title="方案二：利用partition的思想"></a>方案二：利用partition的思想</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt;= arr.length) &#123;<br>            <span class="hljs-keyword">return</span> arr.clone();<br>        &#125;<br>        getLeastNumbers0(arr, <span class="hljs-number">0</span>, arr.length, k);<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res[i] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getLeastNumbers0</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[r - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> l - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; r) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= pivot) &#123;<br>                swap(arr, ++pos, i);<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pos == k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pos &lt; k) &#123;<br>            getLeastNumbers0(arr, pos + <span class="hljs-number">1</span>, r, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            getLeastNumbers0(arr, l, pos, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == j) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-反转链表</title>
    <link href="/2022/11/27/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/11/27/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤n≤1000<br>要求：空间复杂度 O(1)O(1) ，时间复杂度 O(n)O(n) 。</p><p>如当输入链表{1,2,3}时，<br>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。<br>以上转换过程如下图所示：</p><p><img src="/images/pasted-1.png"></p><h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p>输入：<code>&#123;1,2,3&#125;</code></p><p>返回值：<code>&#123;3,2,1&#125;</code></p><h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><p>输入：<code>&#123;&#125;</code></p><p>返回值：<code>&#123;&#125;</code></p><p>说明：空链表则输出空</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h3 id="1-双链表求解"><a href="#1-双链表求解" class="headerlink" title="1,双链表求解"></a>1,双链表求解</h3><p>双链表求解是把原链表的结点一个个摘掉，每次摘掉的链表都让他成为新的链表的头结点，然后更新新链表<br>他每次访问的原链表节点都会成为新链表的头结点，最后再来看下代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> ListNode ReverseList(ListNode head) &#123;<br>    <span class="hljs-comment">//新链表</span><br>    ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//先保存访问的节点的下一个节点，保存起来</span><br>        <span class="hljs-comment">//留着下一步访问的</span><br>        ListNode temp = head.next;<br>        <span class="hljs-comment">//每次访问的原链表节点都会成为新链表的头结点，</span><br>        <span class="hljs-comment">//其实就是把新链表挂到访问的原链表节点的</span><br>        <span class="hljs-comment">//后面就行了</span><br>        head.next = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;<br>        <span class="hljs-comment">//更新新链表</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = head;<br>        <span class="hljs-comment">//重新赋值，继续访问</span><br>        head = temp;<br>    &#125;<br>    <span class="hljs-comment">//返回新链表</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2，使用栈解决"><a href="#2，使用栈解决" class="headerlink" title="2，使用栈解决"></a>2，使用栈解决</h3><p>链表的反转是老生常谈的一个问题了，同时也是面试中常考的一道题。最简单的一种方式就是使用栈，因为栈是先进后出的。实现原理就是把链表节点一个个入栈，当全部入栈完之后再一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。原理如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">ReverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">//把链表节点全部摘掉放到栈中</span><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(head);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (stack.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-comment">//栈中的结点全部出栈，然后重新连成一个新的链表</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempNode</span> <span class="hljs-operator">=</span> stack.pop();<br>            node.next = tempNode;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-comment">//最后一个结点就是反转前的头结点，一定要让他的next</span><br>        <span class="hljs-comment">//等于空，否则会构成环</span><br>        node.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> dummy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-递归解决"><a href="#3-递归解决" class="headerlink" title="3,递归解决"></a>3,递归解决</h3><p>我们再来回顾一下递归的模板，终止条件，递归调用，逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(参数<span class="hljs-number">0</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件)<br>        <span class="hljs-keyword">return</span>;<br><br>    逻辑处理（可能有，也可能没有，具体问题具体分析）<br><br>    <span class="hljs-comment">//递归调用</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> reverseList(参数<span class="hljs-number">1</span>);<br><br>    逻辑处理（可能有，也可能没有，具体问题具体分析）<br>&#125;<br></code></pre></td></tr></table></figure><p>终止条件就是链表为空，或者是链表没有尾结点的时候，直接返回</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">if` `(head == ``null` `|| head.next == ``null``)``  ``<span class="hljs-keyword">return</span>` `head<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>递归调用是要从当前节点的下一个结点开始递归。逻辑处理这块是要把当前节点挂到递归之后的链表的末尾，看下代码</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xquery">public ListNode ReverseList(ListNode<span class="hljs-built_in"> head</span>)&#123;<br><span class="hljs-keyword">return</span> reverseListInt<span class="hljs-built_in">(head</span>,null);<br>&#125;<br><br>private ListNode reverseListInt(ListNode<span class="hljs-built_in"> head</span>,ListNode newHead)&#123;<br><span class="hljs-keyword">if</span><span class="hljs-built_in">(head</span>==null)<br>        <span class="hljs-keyword">return</span> newHead;<br>        ListNode <span class="hljs-keyword">next</span><span class="hljs-built_in">=head</span>.<span class="hljs-keyword">next</span>;<br>       <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>=newHead;<br>        ListNode <span class="hljs-type">node</span>=reverseListInt(<span class="hljs-keyword">next</span><span class="hljs-built_in">,head</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">node</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
